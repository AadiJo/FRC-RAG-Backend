<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRC RAG</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Syntax highlighting for code blocks -->
    <link href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" rel="stylesheet">
    <!-- Markdown renderer and sanitizer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/common.min.js"></script>
</head>
<body>
    <div class="chat-container">
        <!-- Sidebar -->
        <div class="sidebar collapsed">
            <div class="sidebar-header">
                <div class="sidebar-logo">
                    <div class="logo-placeholder">
                        <i class="fas fa-robot"></i>
                    </div>
                    <div class="logo-text">FRC RAG</div>
                </div>
                <button class="new-chat-btn">
                    <i class="fas fa-plus"></i>
                    New Chat
                </button>
            </div>
            <div class="sidebar-content">
                <div class="chat-history">
                    <!-- Chat history will go here -->
                </div>
            </div>
            <div class="sidebar-footer">
                <div class="user-menu">
                    <div class="user-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <span>User</span>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat">
            <!-- Header -->
            <div class="chat-header">
                <div class="header-content">
                    <button class="sidebar-toggle" id="sidebarToggle">
                        <i class="fas fa-bars"></i>
                    </button>
                    <div class="header-title">
                        <h1>FRC RAG</h1>
                    </div>
                </div>
            </div>

            <!-- Chat Messages Area -->
            <div class="chat-messages" id="chatMessages">
                <div class="message assistant-message welcome-message">
                    <div class="message-content">
                        <div class="message-avatar">
                            <div class="assistant-avatar">
                                <i class="fas fa-robot"></i>
                            </div>
                        </div>
                        <div class="message-text-container">
                            <div class="message-text">
                                <h3>Welcome to FRC RAG! ðŸ¤–</h3>
                                <p>I can help you with First Robotics Competition questions using data from team technical binders. Here's what I can do:</p>
                                <ul>
                                    <li><strong>Answer technical questions</strong> about FRC robots, mechanisms, and strategies</li>
                                    <li><strong>Find relevant images</strong> from team documentation</li>
                                    <li><strong>Explain game pieces and mechanisms</strong> with enhanced context</li>
                                    <li><strong>Provide detailed analysis</strong> based on team technical documentation</li>
                                </ul>
                                <p>Try asking me something like:</p>
                                <ul>
                                    <li>"How do teams handle ground intake?"</li>
                                    <li>"Show me swerve drive implementations"</li>
                                    <li>"What are common scoring mechanisms?"</li>
                                </ul>
                                <p><strong>Just type your question below to get started!</strong></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <div class="input-area">
                        <textarea id="messageInput" placeholder="Ask me anything about FRC..."></textarea>
                        <button id="sendButton">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Scroll to bottom button -->
            <button class="scroll-to-bottom" id="scrollToBottomBtn" style="display: none;">
                <i class="fas fa-arrow-down"></i>
            </button>
        </div>

        <!-- Loading Indicator -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-box">
                <div class="loading-content">
                    <div class="loading-stage" id="loadingStage">Querying</div>
                    <div class="loading-progress">
                        <div class="loading-bar" id="loadingBar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-content">
            <span class="image-modal-close" id="modalClose">&times;</span>
            <img class="image-modal-img" id="modalImage" src="" alt="">
            <div class="image-modal-info" id="modalInfo">
                <h3 id="modalTitle"></h3>
                <p id="modalDescription"></p>
            </div>
        </div>
    </div>

    <script>
        // Function declarations first (hoisted)
        function addMessage(text, sender, images = [], isError = false, enhancedData = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message${isError ? ' error-message' : ''}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            if (sender === 'user') {
                avatarDiv.innerHTML = '<div class="user-avatar"><i class="fas fa-user"></i></div>';
            } else {
                avatarDiv.innerHTML = '<div class="assistant-avatar"><i class="fas fa-robot"></i></div>';
            }

            const textContentDiv = document.createElement('div');
            textContentDiv.className = 'message-text-container';

            // Add game piece mapping info if available
            if (enhancedData && enhancedData.matched_pieces) {
                // Handle matched_pieces as either string or array
                let matchedPiecesText = '';
                if (Array.isArray(enhancedData.matched_pieces)) {
                    matchedPiecesText = enhancedData.matched_pieces.join(', ');
                } else {
                    matchedPiecesText = enhancedData.matched_pieces.toString();
                }
                
                if (matchedPiecesText.trim()) {
                    const mappingDiv = document.createElement('div');
                    mappingDiv.className = 'game-piece-mapping';
                    mappingDiv.innerHTML = `
                        <div class="mapping-header">
                            <i class="fas fa-link"></i> Game Piece Mapping
                        </div>
                        <div class="mapping-content">
                            Detected: <strong>${matchedPiecesText}</strong>
                            ${enhancedData.enhanced_query !== enhancedData.query ? 
                                `<br><small>Enhanced search: "${enhancedData.enhanced_query}"</small>` : ''}
                        </div>
                    `;
                    textContentDiv.appendChild(mappingDiv);
                }
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = formatText(text);

            textContentDiv.appendChild(textDiv);

            // Syntax highlight any code blocks
            try {
                textDiv.querySelectorAll('pre code').forEach((block) => {
                    if (window.hljs) window.hljs.highlightElement(block);
                });
            } catch (e) { /* no-op */ }

            // Add images if present
            if (images && images.length > 0) {
                const imagesDiv = document.createElement('div');
                imagesDiv.className = 'message-images';
                
                const imageHeader = document.createElement('div');
                imageHeader.className = 'image-header';
                imageHeader.innerHTML = `<i class="fas fa-images"></i> Related Images (${images.length})`;
                imagesDiv.appendChild(imageHeader);

                const imageGrid = document.createElement('div');
                imageGrid.className = 'image-grid';

                images.forEach((image, index) => {
                    const imageItem = createImageItem(image, index);
                    imageGrid.appendChild(imageItem);
                });

                imagesDiv.appendChild(imageGrid);
                textContentDiv.appendChild(imagesDiv);
            }

            // Add feedback buttons for assistant messages (non-error)
            if (sender === 'assistant' && !isError) {
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'feedback-buttons';
                
                const feedbackLabel = document.createElement('div');
                feedbackLabel.className = 'feedback-label';
                feedbackLabel.textContent = 'Was this response helpful?';
                
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'feedback-button-container';
                
                // Good response button
                const goodButton = document.createElement('button');
                goodButton.className = 'feedback-btn feedback-good';
                goodButton.innerHTML = '<i class="fas fa-thumbs-up"></i> Good';
                goodButton.onclick = () => submitFeedback(text, 'good', feedbackDiv);
                
                // Bad response button
                const badButton = document.createElement('button');
                badButton.className = 'feedback-btn feedback-bad';
                badButton.innerHTML = '<i class="fas fa-thumbs-down"></i> Bad';
                badButton.onclick = () => submitFeedback(text, 'bad', feedbackDiv);
                
                buttonsContainer.appendChild(goodButton);
                buttonsContainer.appendChild(badButton);
                
                // Mark this as the latest assistant message for redo button
                messageDiv.classList.add('latest-assistant-message');
                
                feedbackDiv.appendChild(feedbackLabel);
                feedbackDiv.appendChild(buttonsContainer);
                
                textContentDiv.appendChild(feedbackDiv);
            }

            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textContentDiv);

            messageDiv.appendChild(contentDiv);

            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(messageDiv);
            
            // If this is an assistant message, manage redo button visibility
            if (sender === 'assistant' && !isError) {
                // Remove redo button from all previous assistant messages
                const previousLatestMessages = chatMessages.querySelectorAll('.latest-assistant-message');
                previousLatestMessages.forEach(msg => {
                    if (msg !== messageDiv) {
                        msg.classList.remove('latest-assistant-message');
                        const redoBtn = msg.querySelector('.feedback-redo');
                        if (redoBtn) {
                            redoBtn.remove();
                        }
                    }
                });
                
                // Add redo button to the current (latest) message
                const buttonsContainer = messageDiv.querySelector('.feedback-button-container');
                if (buttonsContainer) {
                    const redoButton = document.createElement('button');
                    redoButton.className = 'feedback-btn feedback-redo';
                    redoButton.innerHTML = '<i class="fas fa-redo"></i> Redo';
                    redoButton.onclick = () => submitFeedback(text, 'redo', messageDiv.querySelector('.feedback-buttons'));
                    buttonsContainer.appendChild(redoButton);
                }
            }
            
            autoScrollToBottom();
        }

        function createImageItem(image, index) {
            const imageDiv = document.createElement('div');
            imageDiv.className = 'image-item';

            if (image.exists) {
                // Create image container for better hover behavior
                const imgContainer = document.createElement('div');
                imgContainer.className = 'image-thumbnail-container';
                
                const img = document.createElement('img');
                img.src = `/images/${image.web_path}`;
                img.alt = image.filename;
                img.className = 'image-thumbnail';
                
                const overlay = document.createElement('div');
                overlay.className = 'image-overlay';
                overlay.innerHTML = `
                    <i class="fas fa-search-plus"></i>
                    <span>Click to view</span>
                `;
                
                // Add click event to container for better handling
                const clickHandler = () => openImageModal(image);
                imgContainer.addEventListener('click', clickHandler);
                
                imgContainer.appendChild(img);
                imgContainer.appendChild(overlay);
                imageDiv.appendChild(imgContainer);
            } else {
                imageDiv.className += ' image-not-found';
                imageDiv.innerHTML = `
                    <div class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <span>Image not found</span>
                    </div>
                `;
            }

            const infoDiv = document.createElement('div');
            infoDiv.className = 'image-info';
            
            // Create the basic info section
            const basicInfo = document.createElement('div');
            basicInfo.className = 'image-basic-info';
            basicInfo.innerHTML = `
                <div class="image-filename">${getTeamDisplayName(image.web_path || image.file_path)}</div>
                <div class="image-page">Page ${image.page || 'N/A'}</div>
            `;
            infoDiv.appendChild(basicInfo);
            
            // Add context summary if available with improved formatting
            if (image.context_summary && image.context_summary.trim()) {
                const contextDiv = document.createElement('div');
                contextDiv.className = 'image-context-summary';
                
                // Truncate long context for better display
                let contextText = image.context_summary.trim();
                if (contextText.length > 120) {
                    contextText = contextText.substring(0, 120) + '...';
                }
                
                contextDiv.innerHTML = `
                    <div class="context-label"><i class="fas fa-info-circle"></i> Context</div>
                    <div class="context-text">${contextText}</div>
                `;
                infoDiv.appendChild(contextDiv);
            }
            
            // Make info div clickable but prevent event bubbling issues
            infoDiv.addEventListener('click', (e) => {
                e.stopPropagation();
                if (image.exists) {
                    openImageModal(image);
                }
            });

            imageDiv.appendChild(infoDiv);
            return imageDiv;
        }

        function openImageModal(image) {
            const imageModal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            
            console.log('Opening modal for image:', image.filename);
            modalImage.src = `/images/${image.web_path}`;
            modalTitle.textContent = getTeamDisplayName(image.web_path || image.file_path);
            
            let modalContent = `
                <strong>Page:</strong> ${image.page || 'N/A'}<br>
                <strong>Path:</strong> ${image.file_path}<br>
            `;
            
            // Show formatted context if available, otherwise fall back to OCR text
            if (image.formatted_context && image.formatted_context.trim()) {
                modalContent += `<div class="formatted-context"><strong>Context:</strong><br><pre class="context-content">${image.formatted_context}</pre></div>`;
            } else if (image.ocr_text && image.ocr_text.trim()) {
                modalContent += `<div class="formatted-context"><strong>OCR Text:</strong><br><pre class="context-content">${image.ocr_text}</pre></div>`;
            }
            
            modalDescription.innerHTML = modalContent;
            imageModal.style.display = 'block';
            console.log('Modal should now be visible');
        }

        function closeModal() {
            const imageModal = document.getElementById('imageModal');
            imageModal.style.display = 'none';
        }

        function formatText(text) {
            // Render Markdown (GFM) and sanitize the HTML output
            try {
                marked.setOptions({ gfm: true, breaks: true, headerIds: false, mangle: false });
                const html = marked.parse(text || '');
                return DOMPurify.sanitize(html);
            } catch (err) {
                const escaped = (text || '')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/\n/g, '<br>');
                return escaped;
            }
        }

        function showLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingStage = document.getElementById('loadingStage');
            loadingOverlay.style.display = 'flex';
            
            // Reset to first stage
            loadingStage.textContent = 'Querying';
            
            // Progress through stages
            setTimeout(() => {
                loadingStage.textContent = 'Processing';
            }, 800);
            
            setTimeout(() => {
                loadingStage.textContent = 'Finishing up';
            }, 2000);
        }

        function hideLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'none';
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hasMessageReachedTop(messageElement) {
            if (!messageElement || !chatMessages) return false;
            const chatRect = chatMessages.getBoundingClientRect();
            const messageRect = messageElement.getBoundingClientRect();
            // Check if the top of the message is at or above the top of the chat container
            return messageRect.top <= chatRect.top;
        }

        function checkPendingTopMessage(force = false) {
            if (!pendingTopMessage) return;

            if (force || hasMessageReachedTop(pendingTopMessage)) {
                console.log('Pending message reached top, disabling auto-scroll.');
                pendingTopMessage = null;
                isAutoScrollEnabled = false;
                // Don't set isUserScrolling here, let the scroll handler manage it.
                if (!isAtBottom()) {
                    scrollToBottomBtn.style.display = 'block';
                }
            }
        }

        function getTeamDisplayName(imagePath) {
            // Extract team number from the file path
            // Path format: "1323-2025/page0_img1.png" or "data/images/1323-2025/page0_img1.png"
            const pathParts = imagePath.split('/');
            
            // Find the folder that contains team number (format: XXXX-YYYY)
            for (let part of pathParts) {
                // Match pattern like "1323-2025" (team number followed by year)
                const match = part.match(/^(\d+)-(\d{4})$/);
                if (match) {
                    const teamNumber = match[1];
                    return `FRC ${teamNumber}`;
                }
            }
            
            // Fallback to original filename if no team pattern found
            return imagePath.split('/').pop();
        }

        // DOM Elements
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalClose = document.getElementById('modalClose');
        const sidebarToggle = document.getElementById('sidebarToggle');
        const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');

        // Global variable to store the current query for feedback
        let currentQuery = '';
        
        // Scroll management
        let isAutoScrollEnabled = false; // Start disabled by default
        let isUserScrolling = false; // Track if user is manually scrolling
        let lastScrollTop = 0;
        let isProgrammaticScroll = false; // Flag to track our own scrolls
        let pendingTopMessage = null;

        // Check if user is at bottom of chat
        function isAtBottom() {
            const threshold = 50; // pixels from bottom
            return chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < threshold;
        }

        // Auto scroll only if enabled
        function autoScrollToBottom() {
            if (isAutoScrollEnabled && !isUserScrolling) {
                isProgrammaticScroll = true;
                chatMessages.scrollTop = chatMessages.scrollHeight;
                lastScrollTop = chatMessages.scrollTop;
                scrollToBottomBtn.style.display = 'none';
                setTimeout(() => { isProgrammaticScroll = false; }, 50);
            } else if (!isAutoScrollEnabled && !isAtBottom()) {
                // Show button if auto-scroll is disabled and not at bottom
                scrollToBottomBtn.style.display = 'block';
            }
        }

        // Force scroll to bottom (when user clicks button)
        function scrollToBottom() {
            console.log('Scroll button clicked - enabling follow mode');
            isAutoScrollEnabled = true; // Enable auto-scroll
            isUserScrolling = false; // Reset user scrolling flag
            isProgrammaticScroll = true;
            chatMessages.scrollTop = chatMessages.scrollHeight;
            lastScrollTop = chatMessages.scrollTop;
            scrollToBottomBtn.style.display = 'none';
            setTimeout(() => { isProgrammaticScroll = false; }, 50);
        }

        // Handle scroll event - detect user scrolling
        chatMessages.addEventListener('scroll', function(e) {
            // Ignore if this is a programmatic scroll
            if (isProgrammaticScroll) {
                return;
            }
            
            const currentScrollTop = chatMessages.scrollTop;
            
            // User is scrolling - disable auto-scroll immediately
            if (isAutoScrollEnabled) {
                console.log('User scrolled - disabling follow mode');
            }
            isUserScrolling = true;
            isAutoScrollEnabled = false;
            pendingTopMessage = null;
            
            // Show/hide button based on position
            if (!isAtBottom()) {
                scrollToBottomBtn.style.display = 'block';
            } else {
                scrollToBottomBtn.style.display = 'none';
            }
            
            lastScrollTop = currentScrollTop;
        });

        // Scroll to bottom button click
        scrollToBottomBtn.addEventListener('click', scrollToBottom);

        // Feedback function
        function submitFeedback(responseText, feedbackType, feedbackDiv) {
            // Disable all buttons in this feedback div to prevent double-clicking
            const buttons = feedbackDiv.querySelectorAll('.feedback-btn');
            buttons.forEach(btn => btn.disabled = true);
            
            // Show loading state
            const buttonsContainer = feedbackDiv.querySelector('.feedback-button-container');
            buttonsContainer.innerHTML = '<span class="feedback-loading"><i class="fas fa-spinner fa-spin"></i> Submitting feedback...</span>';

            fetch('/api/feedback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: currentQuery,
                    response: responseText,
                    feedback_type: feedbackType
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Show success message
                    buttonsContainer.innerHTML = `<span class="feedback-success"><i class="fas fa-check"></i> Thank you for your feedback!</span>`;
                    
                    // If redo was clicked, trigger a new query with the same input
                    if (feedbackType === 'redo') {
                        setTimeout(() => {
                            messageInput.value = currentQuery;
                            sendMessage();
                        }, 1000);
                    }
                } else {
                    // Show error and restore buttons
                    buttonsContainer.innerHTML = '<span class="feedback-error"><i class="fas fa-exclamation-triangle"></i> Failed to submit feedback</span>';
                    setTimeout(() => {
                        location.reload(); // Simple way to restore the interface
                    }, 2000);
                }
            })
            .catch(error => {
                console.error('Feedback error:', error);
                buttonsContainer.innerHTML = '<span class="feedback-error"><i class="fas fa-exclamation-triangle"></i> Failed to submit feedback</span>';
                setTimeout(() => {
                    location.reload(); // Simple way to restore the interface
                }, 2000);
            });
        }

        // Sidebar toggle functionality
        sidebarToggle.addEventListener('click', function() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('collapsed');
        });

        // Event Listeners
        console.log('Setting up event listeners...');
        console.log('sendButton:', sendButton);
        console.log('messageInput:', messageInput);
        
        sendButton.addEventListener('click', function() {
            console.log('Send button clicked!');
            sendMessage();
        });
        
        messageInput.addEventListener('keypress', function(e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        modalClose.addEventListener('click', closeModal);
        imageModal.addEventListener('click', function(e) {
            if (e.target === imageModal) {
                closeModal();
            }
        });

        // Functions
        function sendMessage() {
            console.log('sendMessage function called');
            const message = messageInput.value.trim();
            console.log('Message:', message);
            if (!message) {
                console.log('No message, returning');
                return;
            }

            // Store the current query for feedback
            currentQuery = message;

            console.log('Adding user message to chat');
            // Add user message to chat
            addMessage(message, 'user');
            
            // Clear input
            messageInput.value = '';
            
            // Show loading
            showLoading();

            // Track this user message so we follow the response until it reaches the top
            const userMessages = chatMessages.querySelectorAll('.user-message');
            const lastUserMessage = userMessages[userMessages.length - 1];
            if (lastUserMessage) {
                pendingTopMessage = lastUserMessage;
                isAutoScrollEnabled = true;
                isUserScrolling = false;
                scrollToBottomBtn.style.display = 'none';

                // Immediately snap to the bottom so the conversation follows the assistant
                isProgrammaticScroll = true;
                chatMessages.scrollTop = chatMessages.scrollHeight;
                setTimeout(() => { isProgrammaticScroll = false; }, 50);
            }
            // Use streaming API for ChatGPT-like experience
            sendMessageWithStreaming(message);
        }

        function sendMessageWithStreaming(message) {
            console.log('Sending streaming request to backend...');
            
            // Create a placeholder for the streaming response
            let assistantMessageDiv = null;
            let textDiv = null;
            let currentText = '';
            let metadata = null;
            let hasRenderedVisibleContent = false;
            
            const eventSource = new EventSource(`/api/query/stream?${new URLSearchParams({})}`);
            
            // Use fetch with streaming for POST
            fetch('/api/query/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query: message })
            })
            .then(async response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // DON'T hide loading yet - wait for first content chunk
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        console.log('Stream complete');
                        break;
                    }
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                
                                if (data.type === 'metadata') {
                                    // Received metadata - store it for later use
                                    metadata = data.data;
                                    console.log('Metadata received:', metadata);
                                    
                                    // DON'T hide loading yet - wait for first content token
                                    
                                    // Create the assistant message container
                                    assistantMessageDiv = createStreamingMessageContainer(metadata);
                                    textDiv = assistantMessageDiv.querySelector('.message-text');
                                    
                                } else if (data.type === 'content') {
                                    // Received content chunk - append to message
                                    if (textDiv) {
                                        currentText += data.data;
                                        // Keep the cursor at the end while streaming
                                        textDiv.innerHTML = formatText(currentText) + '<span class="streaming-cursor">|</span>';
                                        
                                        // Hide loading only after visible text is rendered to the screen
                                        if (!hasRenderedVisibleContent) {
                                            requestAnimationFrame(() => {
                                                const renderedText = textDiv.innerText.replace('|', '').trim();
                                                if (!hasRenderedVisibleContent && renderedText.length > 0) {
                                                    hasRenderedVisibleContent = true;
                                                    hideLoading();
                                                    console.log('First content rendered on screen - hiding loading');

                                                    // Auto-scroll to the start of the response
                                                    assistantMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                                }
                                            });
                                        }
                                        
                                        // Syntax highlight code blocks
                                        textDiv.querySelectorAll('pre code').forEach((block) => {
                                            if (window.hljs) window.hljs.highlightElement(block);
                                        });
                                        
                                        // Auto-scroll if enabled
                                        autoScrollToBottom();
                                        checkPendingTopMessage();
                                    }
                                    
                                } else if (data.type === 'done') {
                                    // Stream complete - finalize the message
                                    console.log('Response streaming complete');
                                    if (!hasRenderedVisibleContent) {
                                        hideLoading();
                                    }
                                    checkPendingTopMessage(true);
                                    if (assistantMessageDiv && metadata) {
                                        finalizeStreamingMessage(assistantMessageDiv, currentText, metadata);
                                    }
                                    
                                } else if (data.type === 'error') {
                                    console.error('Stream error:', data.error);
                                    hideLoading();
                                    addMessage(`Error: ${data.error}`, 'assistant', [], true);
                                }
                            } catch (e) {
                                console.error('Error parsing SSE data:', e, line);
                            }
                        }
                    }
                }
            })
            .catch(error => {
                console.error('Detailed error:', error);
                hideLoading();
                addMessage(`Error: ${error.message || error}. Check browser console for details.`, 'assistant', [], true);
            });
        }

        function createStreamingMessageContainer(metadata) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            avatarDiv.innerHTML = '<div class="assistant-avatar"><i class="fas fa-robot"></i></div>';

            const textContentDiv = document.createElement('div');
            textContentDiv.className = 'message-text-container';

            // Add game piece mapping info if available
            if (metadata && metadata.matched_pieces) {
                let matchedPiecesText = '';
                if (Array.isArray(metadata.matched_pieces)) {
                    matchedPiecesText = metadata.matched_pieces.join(', ');
                } else {
                    matchedPiecesText = metadata.matched_pieces.toString();
                }
                
                if (matchedPiecesText.trim()) {
                    const mappingDiv = document.createElement('div');
                    mappingDiv.className = 'game-piece-mapping';
                    mappingDiv.innerHTML = `
                        <div class="mapping-header">
                            <i class="fas fa-link"></i> Game Piece Mapping
                        </div>
                        <div class="mapping-content">
                            Detected: <strong>${matchedPiecesText}</strong>
                            ${metadata.enhanced_query !== metadata.original_query ? 
                                `<br><small>Enhanced search: "${metadata.enhanced_query}"</small>` : ''}
                        </div>
                    `;
                    textContentDiv.appendChild(mappingDiv);
                }
            }

            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = '<span class="streaming-cursor">|</span>'; // Bar cursor

            textContentDiv.appendChild(textDiv);
            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textContentDiv);
            messageDiv.appendChild(contentDiv);

            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(messageDiv);
            autoScrollToBottom();
            
            return messageDiv;
        }

        function finalizeStreamingMessage(messageDiv, finalText, metadata) {
            const textContentDiv = messageDiv.querySelector('.message-text-container');
            const textDiv = messageDiv.querySelector('.message-text');
            
            // Remove cursor
            textDiv.innerHTML = formatText(finalText);
            
            // Add images if present
            if (metadata.images && metadata.images.length > 0) {
                const imagesDiv = document.createElement('div');
                imagesDiv.className = 'message-images';
                
                const imageHeader = document.createElement('div');
                imageHeader.className = 'image-header';
                imageHeader.innerHTML = `<i class="fas fa-images"></i> Related Images (${metadata.images.length})`;
                imagesDiv.appendChild(imageHeader);

                const imageGrid = document.createElement('div');
                imageGrid.className = 'image-grid';

                metadata.images.forEach((image, index) => {
                    const imageItem = createImageItem(image, index);
                    imageGrid.appendChild(imageItem);
                });

                imagesDiv.appendChild(imageGrid);
                textContentDiv.appendChild(imagesDiv);
            }

            // Add feedback buttons
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'feedback-buttons';
            
            const feedbackLabel = document.createElement('div');
            feedbackLabel.className = 'feedback-label';
            feedbackLabel.textContent = 'Was this response helpful?';
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'feedback-button-container';
            
            const goodButton = document.createElement('button');
            goodButton.className = 'feedback-btn feedback-good';
            goodButton.innerHTML = '<i class="fas fa-thumbs-up"></i> Good';
            goodButton.onclick = () => submitFeedback(finalText, 'good', feedbackDiv);
            
            const badButton = document.createElement('button');
            badButton.className = 'feedback-btn feedback-bad';
            badButton.innerHTML = '<i class="fas fa-thumbs-down"></i> Bad';
            badButton.onclick = () => submitFeedback(finalText, 'bad', feedbackDiv);
            
            const redoButton = document.createElement('button');
            redoButton.className = 'feedback-btn feedback-redo';
            redoButton.innerHTML = '<i class="fas fa-redo"></i> Redo';
            redoButton.onclick = () => submitFeedback(finalText, 'redo', feedbackDiv);
            
            buttonsContainer.appendChild(goodButton);
            buttonsContainer.appendChild(badButton);
            buttonsContainer.appendChild(redoButton);
            
            feedbackDiv.appendChild(feedbackLabel);
            feedbackDiv.appendChild(buttonsContainer);
            textContentDiv.appendChild(feedbackDiv);
            
            // Mark as latest assistant message
            messageDiv.classList.add('latest-assistant-message');
            
            // Remove redo from previous messages
            const chatMessages = document.getElementById('chatMessages');
            const previousLatestMessages = chatMessages.querySelectorAll('.latest-assistant-message');
            previousLatestMessages.forEach(msg => {
                if (msg !== messageDiv) {
                    msg.classList.remove('latest-assistant-message');
                    const redoBtn = msg.querySelector('.feedback-redo');
                    if (redoBtn) redoBtn.remove();
                }
            });
            
            autoScrollToBottom();
        }


        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, focusing input');
            messageInput.focus();
            console.log('Page fully loaded and ready!');
        });
    </script>
</body>
</html>